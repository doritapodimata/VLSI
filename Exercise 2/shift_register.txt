module shift_register # (parameter n=8)(input si,pl,en,clk,rstn, input [n-1:0] din, output reg so);
	
	reg [n-1:0] register;

	always @(posedge clk or negedge rstn) begin
		if(rstn==0)begin
		register<=0;
		end
	else if(pl==1)begin
		register<=din;
		end
	else if(en==1)begin
		so<=register[0];
		register<=register>>1;
		register[n-1]<=si;
	end
	end
endmodule
		
			
module shifttb;
	
	reg [7:0] data, test;
	reg clk, en, rstn, pl, si;
	reg check;
	wire so;	

	shift_register #(8) shift (.si(si),.pl(pl),.en(en),.clk(clk),.rstn(rstn),.din(data),.so(so));

	always #5 clk=~clk;

	initial begin 
	clk<=0;
	rstn<=0;
	en<=0;
	pl<=1;
	si<=0;

	data<=8'h2c;
	test<=8'h00;

	#5 rstn=1;
	#10 pl=0;
	en=1;

	repeat(8)@(posedge clk) begin
		#1 test=test>>1;
		test[7]<=so;
	end

	if(data==test)
		check<=1;
	else
		check<=1'bx;
		
	end
endmodule 

/*module shifttb;
	
	reg [7:0] data[3:0];
	reg [7:0] in;
	reg [1:0] data_index;
	reg [7:0] test[3:0];
	reg clk,en,rstn,pl,si;
	reg check;
	wire so;
	integer i;
	
	assign in={data[0],data[1],data[2],data[3]};

	shift_register #(8) shift (.si(si),.pl(pl),.en(en),.clk(clk),.rstn(rstn),.din(in),.so(so));

	always #5 clk=~clk;

	initial begin 
	clk<=0;
	rstn<=0;
	en<=0;
	pl<=1;
	si<=0;

	data_index<=0;
	data[0]<=8'had;
	data[1]<=8'h3a;
	data[2]<=8'h55;
	in<=data[0];

	/*for(i=0;i<4;i=i+1)begin
		data[i]=$random;
	end*/

	test<=8'h00;

	#5 rstn=1;
	#10 pl=0;
	en=1;

	repeat(8)@(posedge clk) begin
		#1 test=test>>1;
		test[7]<=so;
	end

	if(data[data_index]==test[data_index])
		check<=1;
	else
		check<=1'bx;
		data_index = data_index + 1;
        if (data_index >= 3)
            data_index = 0;
	end
endmodule*/
